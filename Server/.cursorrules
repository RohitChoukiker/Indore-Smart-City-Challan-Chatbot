# MediAid Backend - Cursor AI Rules

## Project Context
This is a FastAPI-based pharmacy management system following a strict 3-layer architecture pattern.
**Complete documentation:** See `CODING_RULES.md` for all 53 detailed rules.

## Architecture Principles

### 1. 3-Layer Architecture (MANDATORY)
Every feature module MUST have exactly 3 files:
```
module_name/
├── {module}_controller.py  # Routes only - NO business logic
├── {module}_service.py     # All business logic + database operations
└── {module}_dto.py         # Pydantic schemas for request/response
```

**Layer Responsibilities:**
- **Controller**: HTTP routing, dependency injection, call service functions
- **Service**: Business logic, database operations, validations, return standardized responses
- **DTO**: Pydantic models for data validation

### 2. Separation of Concerns
❌ NEVER put database queries in controllers
❌ NEVER put HTTP logic in services
❌ NEVER mix business logic in controllers

## Naming Conventions (STRICT)

| Element | Convention | Example |
|---------|-----------|---------|
| Files | `snake_case.py` | `auth_controller.py` |
| Routers | `camelCaseRouter` | `authRouter`, `onboardRouter` |
| Models/DTOs | `PascalCase` | `Users`, `OtpRequest` |
| Public functions | `snake_case` | `request_otp`, `get_profile` |
| Service functions | `snake_case_service` | `request_otp_service` |
| Private functions | `_snake_case` | `_normalize_mobile` |
| Variables | `snake_case` | `current_user_id` |

## Standardized Response Format (MANDATORY)

ALL endpoints MUST return this exact structure:
```python
{
    "status": bool,      # True = success, False = error
    "message": str,      # Human-readable message
    "data": Any | None   # Payload or None
}
```

**Examples:**
```python
# Success
return {"status": True, "message": "OTP sent to your mobile number", "data": {"user_id": "..."}}

# Error
return {"status": False, "message": "User not found", "data": None}
```

## Database Session Management (MANDATORY)

ALL service functions MUST follow this pattern:
```python
def service_name_service(params):
    db: Session = SessionLocal()
    try:
        # 1. Validation
        if not valid:
            return {"status": False, "message": "Error message", "data": None}
        
        # 2. Database operations
        result = db.query(Model).filter(...).first()
        
        # 3. Business logic
        # Process data
        
        # 4. Commit changes
        db.commit()
        
        # 5. Return success
        return {"status": True, "message": "Success", "data": {...}}
    except Exception as e:
        db.rollback()
        return {"status": False, "message": str(e), "data": None}
    finally:
        db.close()  # ALWAYS close the session
```

## Controller Pattern (MANDATORY)

Keep controllers thin - only route definitions:
```python
# Good ✅
@authRouter.post("/login")
def request_otp(req: OtpRequest):
    return request_otp_service(req)

# Bad ❌ - No business logic in controllers
@authRouter.post("/login")
def request_otp(req: OtpRequest):
    db = SessionLocal()
    user = db.query(Users).filter(...).first()  # WRONG!
```

## Dependency Injection for Auth

Use private functions for reusable dependencies:
```python
def _user_id_dep(authorization: Optional[str] = Header(default=None, alias="Authorization")):
    user_id = get_user_id_from_token(authorization)
    if not user_id:
        raise HTTPException(status_code=401, detail="Unauthorized")
    return user_id

@router.get("/profile")
def get_profile(user_id = Depends(_user_id_dep)):
    return get_profile_service(user_id)
```

## SQLAlchemy Model Structure

```python
class ModelName(Base):
    __tablename__ = "table_name"
    
    # 1. Primary key first
    id = Column(String(36), primary_key=True, default=generate_uuid)
    
    # 2. Regular columns (grouped logically)
    name = Column(String(100), nullable=True)
    email = Column(String(100), nullable=True)
    
    # 3. Timestamps (ALWAYS include these)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # 4. Relationships last
    stores = relationship("Store", back_populates="user")
```

## Pydantic DTO Pattern

```python
from pydantic import BaseModel, EmailStr, Field
from typing import Optional

class ResourceCreate(BaseModel):
    name: Optional[str] = None
    email: Optional[EmailStr] = None  # Use EmailStr for emails
    mobile: str = Field(..., description="10 or 12 digit mobile")

class ResourceUpdate(ResourceCreate):
    pass  # Inherit when structures are identical
```

## Import Order (MANDATORY)

```python
# 1. Standard library
from datetime import datetime
from typing import Optional

# 2. Third-party packages
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

# 3. Local application imports
from .module_dto import DTOClass
from .module_service import service_function
from src.utils.auth_utils import get_user_id_from_token
```

## Type Hints (MANDATORY)

Always use type hints:
```python
def function_name(param: str, optional: Optional[int] = None) -> dict:
    return {"status": True, "message": "Done", "data": None}
```

## Database Operations

### Query Patterns
```python
# Single record
user = db.query(Users).filter(Users.mobile == mobile).first()

# Check existence
existing = db.query(Store).filter(Store.user_id == user_id).first()
if existing:
    return {"status": False, "message": "Already exists", "data": None}
```

### Create Pattern
```python
new_record = ModelName(
    id=str(uuid.uuid4()),
    field1=value1,
    field2=value2,
    created_at=datetime.utcnow(),
    updated_at=datetime.utcnow(),
)
db.add(new_record)
db.commit()
db.refresh(new_record)  # Get DB-generated values
```

### Update Pattern
```python
# Conditional updates
if payload.field is not None:
    record.field = payload.field

# Or dynamic for multiple fields
for field in ["field1", "field2", "field3"]:
    value = getattr(payload, field, None)
    if value is not None:
        setattr(record, field, value)

record.updated_at = datetime.utcnow()  # ALWAYS update timestamp
db.commit()
```

## Authentication Rules

### JWT Token Creation
```python
def _create_token(payload: dict, days: int = 180) -> str:
    to_encode = payload.copy()
    to_encode.update({"exp": datetime.utcnow() + timedelta(days=days)})
    return jwt.encode(to_encode, JWT_SECRET, algorithm=JWT_ALG)
```

### OTP Management
- Store OTP in database with `otp` and `otp_created_at` fields
- Expiration: 5 minutes
- Always clear OTP after successful verification
```python
user.otp = otp
user.otp_created_at = datetime.utcnow()
db.commit()
```

## Router Registration

In `main.py`:
```python
app.include_router(moduleRouter, prefix="/api/module")
```

Create router in controller:
```python
moduleRouter = APIRouter(tags=["Module Name"])
```

## Environment Configuration

Use environment variables with defaults:
```python
from dotenv import load_dotenv
load_dotenv()

JWT_SECRET = os.getenv("JWT_SECRET", "dev_secret")
```

## UUID Primary Keys

Always use string UUIDs:
```python
def generate_uuid() -> str:
    return str(uuid.uuid4())

id = Column(String(36), primary_key=True, default=generate_uuid)
```

## Error Handling

### In Services
```python
try:
    # operations
    return {"status": True, "message": "Success", "data": result}
except Exception as e:
    db.rollback()
    return {"status": False, "message": str(e), "data": None}
finally:
    db.close()
```

### In Controllers (for auth)
```python
if not user_id:
    raise HTTPException(status_code=401, detail="Unauthorized")
```

## Data Type Conversions

Convert Decimal to string for JSON:
```python
"lat": str(record.lat) if record.lat is not None else None,
"long": str(record.long) if record.long is not None else None,
```

## File Upload Handling

```python
from fastapi import UploadFile, File, Form

@router.post("/upload")
async def upload(
    user_id = Depends(_user_id_dep),
    file: Optional[UploadFile] = File(default=None),
    text_field: Optional[str] = Form(default=None),
):
    image_bytes = await file.read()
    # process file
```

## Code Generation Checklist

When generating a new module, ALWAYS ensure:

1. ✅ Created 3 files: `{module}_controller.py`, `{module}_service.py`, `{module}_dto.py`
2. ✅ Controller only has route definitions
3. ✅ Service has try-except-finally with db.close()
4. ✅ All services return `{"status": bool, "message": str, "data": Any | None}`
5. ✅ DTOs use Pydantic BaseModel
6. ✅ Type hints on all functions
7. ✅ Private helpers use `_` prefix
8. ✅ Models have `created_at` and `updated_at`
9. ✅ Router registered in `main.py`
10. ✅ Import order: stdlib → third-party → local

## Common Mistakes to Avoid

❌ **DON'T** put business logic in controllers
❌ **DON'T** forget db.close() in finally block
❌ **DON'T** forget to rollback on exceptions
❌ **DON'T** mix response formats
❌ **DON'T** forget type hints
❌ **DON'T** use inconsistent naming conventions
❌ **DON'T** forget to update `updated_at` timestamp
❌ **DON'T** create modules without all 3 required files

## Tech Stack Reference

- **Framework:** FastAPI 0.116.1
- **ORM:** SQLAlchemy 2.0.43
- **Validation:** Pydantic 2.11.7
- **Auth:** JWT (PyJWT 2.10.1)
- **Database:** MySQL (PyMySQL) with SQLite fallback
- **HTTP Client:** httpx 0.28.1

## Documentation Requirements

- Module docstrings at file top
- Function docstrings for complex logic
- Inline comments for non-obvious operations
- Tag all routers for API docs

---

**Complete Rules:** See `CODING_RULES.md` for comprehensive documentation with all 53 rules and examples.

**Project Structure:** Active code is in `src/` directory. `Backend/modules/` is legacy/unused.

